{"name":"Pi Pin Manager","tagline":"Setup Raspberry Pi GPIO pins using a configuration file, not boilerplate","body":"Boilerplate code is annoying and sometimes there can be a lot of it working with [Raspberry Pi GPIO](https://pypi.python.org/pypi/RPi.GPIO). I got tired of setting the board mode and declaring GPIO channels in every script so I made a library that uses a config file instead. In addition to getting rid of the boilerplate, **Pi-Pin-Manager** has the added benefit of pulling the configuration out of the code. This means you can modify any pin's behavior without ever touching a Python file or having to redeploy your program.\r\n\r\n\r\n### Install it\r\n\r\n```\r\npip install Pi-Pin-Manager\r\n```\r\n\r\n### Configure it\r\n\r\nWhen creating an instance of `pi_pin_manager.PinManager`, there are two ways you can supply pin configuration information: A config file, written in [YAML](http://en.wikipedia.org/wiki/YAML) or a dictionary. If a pin is not defined at this step it will not be available to the `PinManager`.\r\n\r\n#### With file\r\n\r\nThe following snippet shows an example configuration file:\r\n\r\n```yaml\r\n18:\r\n  mode: OUT\r\n  initial: HIGH\r\n23:\r\n  mode: OUT\r\n  initial: LOW\r\n24:\r\n  mode: IN\r\n  event: RISING\r\n  handler: do_something\r\n  bounce: 200\r\n```\r\n\r\n#### With dictionary\r\n\r\nThis snippet shows the same configuration example above as a dictionary:\r\n\r\n```python\r\nconfig = {\r\n  18:\r\n    'mode': 'OUT'\r\n    'initial': 'HIGH'\r\n  23:\r\n    'mode': 'OUT'\r\n    'initial': 'LOW'\r\n  24:\r\n    'mode': 'IN'\r\n    'event': 'RISING'\r\n    'handler': 'do_something'\r\n    'bounce': 200\r\n}\r\n```\r\n\r\n#### Notes\r\n\r\n* Add a numbered element for each pin to enable\r\n* `mode` - This controls whether the pin will be used for input or output. Accepted values are: `IN`, `OUT`. (Required)\r\n* `initial` - This controls the starting value of the pin. Accepted values are: `LOW`, `HIGH`. (Optional - defaults to `LOW`)\r\n* `resistor` - This controls the software defined pull up/pull down resistor available in the Broadcom SOC. Accepted values are: `PUD_UP`, `PUD_DOWN`. (Optional - defaults to none)\r\n* `event` - This is used in combination with a pin set to input mode (`mode: IN`). Accepted values are: `RISING`, `FALLING`, `BOTH`.\r\n* `handler` - This is used in combination with an `event` to designate a function to call when an `event` happens. This value should correspond to a method defined in your handler class.\r\n* `bounce` - This can be used when an `event` is defined to prevent multiple `handler` calls being fired accidentally. The value is the number of milliseconds to wait before detecting another `event`.\r\n\r\nFor full documentation about available GPIO input pin configurations see the [documentation](http://sourceforge.net/p/raspberry-gpio-python/wiki/Examples/).\r\n\r\n\r\n### Single Pin Watcher\r\n\r\nSometimes, you just need something to watch for an event on one pin and fire off a custom function when that event is detected. This is a perfect use case for the `SinglePinWatcher`. It takes two parameters:\r\n* A config file or dictionary as outlined above. However this config can only have one pin defined. If more than one pin definition is found a `PinConfigurationError` will be raised.\r\n* An action function. This function will be called each time the pin `event` (from config) is detected. The function you define for this must accept a single parameter. An instance of the GPIO module will be passed into the function when it is called. This allows you to check the value of the pin in situations where you are detecting both (`event: BOTH`) a rising and falling event.\r\n\r\n**Example Config File:**\r\n```yaml\r\n23:\r\n  mode: IN\r\n  initial: HIGH\r\n  resistor: PUD_UP\r\n  event: BOTH\r\n  bounce: 200\r\n```\r\n\r\n\r\n```python\r\nfrom pi_pin_manager import SinglePinWatcher\r\n\r\ndef my_action(gpio):\r\n  # Whatever you want to happen when an event is detected goes here\r\n  print(\"Event detected!\")\r\n  print(gpio.input(23))\r\n\r\nwatcher = SinglePinWatcher(config='path/to/config/file.yml', action=my_action)\r\n\r\nwatcher.start()\r\n```\r\n\r\n\r\n### Multiple Pin Watcher\r\n\r\nThe `MultiplePinWatcher` can simultaneously watch multiple pins, and fire off custom actions when events are detected. It takes two parameters:\r\n* A config file or dictionary as outlined above.\r\n* An event handler class. The class contstructor must take one parameter. An instance of the GPIO module will be passed into the constructor when it is called. This class must also have method names that match the `handler` names used in the config file. The methods you define for this must accept a single parameter. The number of the pin will be passed in automatically into the method when it is called.\r\n\r\n**Example Config File:**\r\n```yaml\r\n18:\r\n  mode: IN\r\n  initial: HIGH\r\n  resistor: PUD_UP\r\n  event: FALLING\r\n  bounce: 200\r\n  handler: do_something\r\n\r\n23:\r\n  mode: IN\r\n  initial: HIGH\r\n  resistor: PUD_UP\r\n  event: BOTH\r\n  bounce: 200\r\n  handler: do_something_else\r\n```\r\n\r\n\r\n```python\r\nfrom pi_pin_manager import MultiplePinWatcher\r\n\r\n\r\nclass MyHandler(object):\r\n\r\n  def __init__(self, gpio):\r\n    self._gpio = gpio\r\n\r\n  def do_something(self, pin):\r\n    # Whatever you want to happen when an event is detected goes here\r\n    print(\"PIN {0}!!!\".format(pin))\r\n\r\n  def do_something_else(self, pin):\r\n    # Whatever you want to happen when an event is detected goes here\r\n    print(\"PIN {0}!!!\".format(pin))\r\n\r\nwatcher = MultiplePinWatcher(config='path/to/config/file.yml', event_handler=MyHandler)\r\n\r\nwatcher.start()\r\n```\r\n\r\n\r\n### Pin Manager (no event)\r\n\r\n```python\r\nfrom pi_pin_manager import PinManager\r\n\r\n\r\n# With configuration file\r\npins = PinManager(config_file='path/to/config/file.yml')\r\n\r\n# With configuration dictionary, assuming my_config_dictionary was defined\r\n# pins = PinManager(config_dict=my_config_dictionary)\r\n\r\n\r\n# Read a pin\r\nresult = pins.read(18)\r\n\r\n# Write to a pin\r\npins.write(19, 1)\r\n\r\n# Turn pin on\r\npins.on(19)\r\n\r\n# Turn pin off\r\npins.off(19)\r\n\r\n# Get configuration for a pin\r\nresult = pins.get_config(23)\r\n\r\n# Get configuration for all pins\r\nresult = pins.get_config()\r\n\r\n# Cleanup GPIO on single pin\r\npins.cleanup(18)\r\n\r\n# Cleanup GPIO on all pins\r\npins.cleanup()\r\n```\r\n\r\n### Pin Manager (with event)\r\n\r\nIf an `event` and `handler` have been defined for a pin in the config file, then you must also provide a class that contains the callbacks to execute. Each method you add to this class should match the name of a `handler` value. Based on the example code below, `handler: do_something` is expected in the config file `path/to/config/file.yml`.\r\n\r\n```python\r\nfrom pi_pin_manager import PinManager\r\n\r\n\r\nclass EventHandlers(object):\r\n\r\n    def __init__(self, gpio):\r\n      self._gpio = gpio\r\n\r\n    def do_something(self, pin_number):\r\n        # Whatever you want to trigger when an event is detected goes here\r\n        # You have access to the GPIO object as self._gpio\r\n        print('pin {0}'.format(pin_number))\r\n\r\n\r\npins = PinManager(config_file='path/to/config/file.yml', event_handlers=EventHandlers)\r\n\r\n# With configuration dictionary, assuming my_config_dictionary was defined\r\n# pins = PinManager(config_dict=my_config_dictionary, event_handlers=EventHandlers)\r\n```\r\n\r\n### Exceptions\r\n\r\nThis package may raise the following custom exceptions:\r\n\r\n* `PinNotDefinedError` - This is raised when attempting to `read` or `write` to a pin that is not defined in the configuration file.\r\n* `PinConfigurationError` - This is raised when attempting to perform an action on a pin that does not match its configuration. For example, trying to `write` to a pin not defined as `mode: OUT`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}